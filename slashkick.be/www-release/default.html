<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>/KICK</title>

	<link type="text/css" href="css/main.css" rel="stylesheet" />

	<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.22/require.min.js"></script>

	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js"></script>

	<script src="scripts/main.js"></script>

	<!-- vertex shader -->
	<script id="vertexShader" type="x-shader/x-vertex">

  void main() {
    gl_Position = vec4( position, 1.0 );
  }

	</script>

	<!-- fragment shader -->
	<script id="fragmentShader" type="x-shader/x-fragment">
	precision mediump float;

	uniform sampler2D kickTexture;
  uniform vec3 iResolution;
  uniform float iGlobalTime;
  uniform vec4 iMouse;
  uniform vec4 iDate;
  uniform float iFFT;





highp float rand(vec2 co)
{
    highp float a = 12.9898;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}






const float pixelSize = 2.;
const float idealColorChangeWidth = .82;// % of scan width
const float animatedPerturbanceAmt = 0.04;// % of scan width
const float fixedPerturbanceAmt = 0.04;// % of scan width

const float animationSpeed = 15.0;


//----------------------------------------------------------------------
// c64 palette
vec3 color0 = vec3(0,0,0);// black
vec3 color1 = vec3(1,1,1);// white
vec3 color2 = vec3(0.41,0.22,0.17);// red
vec3 color3 = vec3(0.44,0.64,0.70);// cyan
vec3 color4 = vec3(0.44,0.24,0.53);// violet
vec3 color5 = vec3(0.35,0.55,0.26);// green
vec3 color6 = vec3(0.21,0.16,0.47);// blue
vec3 color7 = vec3(0.72,0.78,0.44);// yellow
vec3 color8 = vec3(0.44,0.31,0.15);// orange
vec3 color9 = vec3(0.26,0.22,0);// brown
vec3 colorA = vec3(0.60,0.40,0.35);// light red
vec3 colorB = vec3(0.27,0.27,0.27);// grey1
vec3 colorC = vec3(0.42,0.42,0.42);// grey2
vec3 colorD = vec3(0.60,0.82,0.52);// light green
vec3 colorE = vec3(0.42,0.37,0.71);// light blue
vec3 colorF = vec3(0.58,0.58,0.58);// grey3

float quantize(float x, float s) { return floor(x/s)*s; }
vec2 quantize(vec2 x, float s) { return floor(x/s)*s; }


highp float hash(highp  float n )
{
    return fract(sin(n)*43758.5453);
}

vec3 tenfourGradient(float x)
{
	const float colCount = 16.;
    x = floor(fract(x) * colCount);
    float i = 0.;
    if(x == i++) return color0;// black
    if(x == i++) return colorB;// grey1
    if(x == i++) return colorC;// grey2
    if(x == i++) return colorF;// grey3
    if(x == i++) return color1;// white

    if(x == i++) return color7;// yellow
    if(x == i++) return colorD;// light green
    if(x == i++) return color3;// cyan
    if(x == i++) return color5;// green

    if(x == i++) return colorE;// light blue
    if(x == i++) return color4;// violet
    if(x == i++) return color6;// blue

    if(x == i++) return color9;// brown
    if(x == i++) return color2;// red
    if(x == i++) return color8;// orange
    if(x == i++) return colorA;// light red
    return vec3(0);
}

vec3 dumbGradient(float x)
{
	const float colCount = 16.;
    x = floor(fract(x) * colCount);
    float i = 0.;
    if(x == i++) return color0;// black
    if(x == i++) return color1;// white
    if(x == i++) return color2;// red
    if(x == i++) return color3;// cyan
    if(x == i++) return color4;// violet
    if(x == i++) return color5;// green
    if(x == i++) return color6;// blue
    if(x == i++) return color7;// yellow
    if(x == i++) return color8;// orange
    if(x == i++) return color9;// brown
    if(x == i++) return colorA;// light red
    if(x == i++) return colorB;// grey1
    if(x == i++) return colorC;// grey2
    if(x == i++) return colorD;// light green
    if(x == i++) return colorE;// light blue
    if(x == i++) return colorF;// grey3
    return vec3(0);
}

vec3 greenBlueGradient(float x)
{
	const float colCount = 19.;
    x = floor(fract(x) * colCount);
    float i = 0.;

    if(abs(x-i) < 1.5) return color6;
    
    //if(x - i++)<.5) return color0;// black
    if(x == i++) return colorB;// grey1
    if(x == i++) return colorC;// grey2
    if(x == i++) return colorF;// grey3
    if(x == i++) return color1;// white

    if(x == i++) return colorD;// light green
    if(x == i++) return color5;// green
    if(x == i++) return colorD;// light green
    if(x == i++) return color1;// white

    if(x == i++) return color3;// cyan
    if(x == i++) return colorE;// light blue
    if(x == i++) return color4;// violet
    if(x == i++) return color6;// blue

    if(x == i++) return color4;// violet
    if(x == i++) return colorE;// light blue
    if(x == i++) return color3;// cyan

    if(x == i++) return color1;// white
    if(x == i++) return colorF;// grey3
    if(x == i++) return colorC;// grey2
    if(x == i++) return colorB;// grey1

    return vec3(.5);
}

//----------------------------------------------------------------------

void getRasterColor( out vec4 o, vec2 i)
{
    vec2 pVirt = floor(i / pixelSize);// pixel coords in simulated screen space.
    vec2 virtRes = floor(iResolution.xy / pixelSize);
    vec2 uv = pVirt / virtRes;

    float linPixel = pVirt.x + (pVirt.y * virtRes.x);
    float bandWidth = virtRes.x * idealColorChangeWidth;// with no glitches, color bands span X% of the screen.
    linPixel -= (hash(pVirt.y)*2.-1.)*virtRes.x*fixedPerturbanceAmt;// perturb by Y up to X% of screen width
    linPixel -= (hash(iGlobalTime)*2.-1.)*virtRes.x*animatedPerturbanceAmt;// perturb by time up to X% of screen width
    linPixel += virtRes.x *floor(iGlobalTime*animationSpeed);// animate by shifting whole scan lines
    float band = linPixel / bandWidth;
    
    // select which gradient to show
    if(mod(iGlobalTime, 3.) < 2.)
    {
        float p = fract(band / 100.);
        if(p < 0.5)
            o = vec4(tenfourGradient(band/16.),1.);
        else
            o = vec4(greenBlueGradient(band/19.),1.);
    }
    else
    {
    	o = vec4(dumbGradient(band/16.),1.);
    }

}

















// convert distance to alpha
float dtoa(float d, float amount)
{
    float a = clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);
    return a;
}

// float tri(float i, float p)
// {
//     return abs(mod(abs(i),(p*2.)) - p) / p;
// }

// float tri_gear(float i, float p, float cmin, float cmax)
// {
//     return clamp(tri(i,p), cmin, cmax);
// }

void band(inout vec3 o, vec2 uv, float y, vec3 c)
{
    y -= .3;
    float fft = .5 + iFFT / 2.;

    //float ext = y + tri_gear(uv.x + (iGlobalTime * .5) - (iFFT * 1.), 0.2, 1.-fft, fft);
    float ext = y + .5;

    float amt = 400.-(1000.0*pow(iFFT, 0.5));
    amt = clamp(amt, 10., 400.);
    amt = 900.;
    o.rgb = mix(o.rgb, c, dtoa(uv.y - ext, amt));
}

float pixellate(float i, float sz)
{
    return floor(i / sz) * sz;
}

// vec3 colorRasterBar(vec2 uvPix)
// {
//     float rasterRow = pixellate(uvPix.y , 2.);
//     float rowSeed = rand(vec2(rasterRow));
//     float rasterColumn = pixellate(uvPix.x + (rowSeed-.5) * iGlobalTime * 2000., 300.*rowSeed);
//     vec3 c = rasterColorLinear(
//     	rand(vec2(rasterColumn, rasterRow))
//     	);
//     //c *= vec3(0.2,.3,0.2);
//     return c;
// }

// // o = output color
// // uv = uv coords
// // y = where you want this band
// // uvPix = screen pixel coords
// void raster_band(inout vec3 o, vec2 uv, float y, vec2 uvPix)
// {
//     y -= .3;
//     float fft = .5 + iFFT / 2.;

//     float ext = y + tri_gear(uv.x + (iGlobalTime * .5) - (iFFT * 1.), 0.2, 1.-fft, fft);

//     float amt = 400.-(1000.0*pow(iFFT, 0.5));
//     amt = clamp(amt, 10., 400.);

//     // figure out color.
//     vec3 c = colorRasterBar(uvPix);
//     // float rasterRow = pixellate(uvPix.y , 4.);
//     // float rowSeed = rand(vec2(rasterRow));
//     // float rasterColumn = pixellate(uvPix.x + (rowSeed-.5) * iGlobalTime * 2000., 300.*rowSeed);
//     // vec3 c = vec3(
//     // 	rand(vec2(rasterColumn + .00, rasterRow)),
//     // 	rand(vec2(rasterColumn + .33, rasterRow)),
//     // 	rand(vec2(rasterColumn + .66, rasterRow))
//     // 	);

//     o.rgb = mix(o.rgb, c, dtoa(uv.y - ext, amt));
// }



float sdSegment1D(float uv, float a, float b)
{
    return max(max(a - uv, 0.), uv - b);
}
float sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)
{
    float dx = sdSegment1D(uv.x,tl.x,br.x);
    float dy = sdSegment1D(uv.y,tl.y,br.y);
    return dx + dy;// manhattan
    //return sqrt(dx*dx+dy*dy);// euclidian version
}

void blit(inout vec3 o, vec2 uv, vec2 pos, vec2 destSize, vec2 uvPix)
{
    uv -= pos;
    uv /= destSize;

    float d = sdAxisAlignedRect(uv, vec2(0.), vec2(1.));
    float alpha = step(d, 0.);
    // causes artifacts. we actually need to sample and use alpha instead
    //if(alpha < 0) return;

    //uv.y = 1.-uv.y;// flip y coord
    vec4 s = texture2D(kickTexture, uv);
    //o = mix(o.rgb, s.rgb, s.a * alpha);

    vec4 rasterColor = vec4(0);
    //getRasterColor(rasterColor, uvPix);
    //rasterColor = vec4(1);

    o = mix(o.rgb, rasterColor.rgb, s.a * alpha);
}


// void slash_raster(inout vec3 o, vec2 uv, float left, float right, vec2 uvPix)
// {
// 	vec3 col = colorRasterBar(uvPix);

//     uv.x -= (uv.y*.7);
//     float d = sdAxisAlignedRect(uv, vec2(left,-1), vec2(right,1));
//     o = mix(o, col, 1.-smoothstep(0.,.007,d));
// }

void slash_color(inout vec3 o, vec2 uv, float left, float right, vec3 col)
{
    uv.x -= (uv.y*.7);
    float d = sdAxisAlignedRect(uv, vec2(left,-1), vec2(right,1));
    o = mix(o, col, 1.-smoothstep(0.,.007,d));
}


	void main()
	{
 		vec2 i = gl_FragCoord.xy;
// 		//////////////////////////////////////////////////////////////////////////////

// gl_FragColor = vec4(.5);
//     getRasterColor(gl_FragColor, i);
// gl_FragColor.a = 1.;
//     return;

// 		vec2 uv = gl_FragCoord.xy / iResolution.xy - .5;
// 		uv *= 3.;// -1.5 to 1.5
// 		uv += vec2(.3,-.3);
// 		// add padding to correct aspect.
// 		if(iResolution.x > iResolution.y)
// 			uv.x *= iResolution.x / iResolution.y;
// 		else
// 			uv.y /= iResolution.x / iResolution.y;
		
// 		uv.y -= uv.x * .3333;// shear

// 		vec2 uvPix = gl_FragCoord.xy;
// 		uvPix.y -= uvPix.x * .3333;

//     getRasterColor(gl_FragColor, uvPix);
// gl_FragColor.a = 1.;
//     return;



		vec2 uv = gl_FragCoord.xy / iResolution.xy - .5;
		uv *= 2.1;// -1.5 to 1.5
		uv += vec2(.3,-.3);
		// add padding to correct aspect.
		if(iResolution.x > iResolution.y)
			uv.x *= iResolution.x / iResolution.y;
		else
			uv.y /= iResolution.x / iResolution.y;
		
		uv.y -= uv.x * .3333;// shear

		vec2 uvPix = gl_FragCoord.xy;
		uvPix.y -= uvPix.x * .3333;

    vec4 rasterColor = vec4(1);
    getRasterColor(rasterColor, uvPix);

		//mainImage(o, i);
		//i /= iResolution.xy;
		//o = vec4(sin(length(i)*10.)*.5+.5);

    //float2 uv = inp.uv;

    //float4 o = float4(1,1,1,1);

    vec4 o = vec4(color6,1);// vec4(0,0,1,1);
    band(o.rgb, uv, .8, vec3(0,0,0));

   	band(o.rgb, uv, .75, color8);// vec3(1,.5,0)
   	//band(o.rgb, uv, .6, vec3(1,.5,0));
   	band(o.rgb, uv, .62, rasterColor.rgb);
   	band(o.rgb, uv, .34, vec3(0));

    //band(o.rgb, uv, .3, vec3(.5,.5,.5));

    // slash
    vec3 grayColor = vec3(.5,.5,.5);

    //grayColor = rasterColor.rgb;

    //slash_color(grayColor, uv, -.8, -.54, vec3(.0,.2,.0));
    //slash_raster(grayColor, uv, -.75, -.59, uvPix);

    slash_color(grayColor, uv, -.8, -.54, vec3(.2,.2,.2));
    //slash_color(grayColor, uv, -.8, -.54, rasterColor.rgb);
    slash_color(grayColor, uv, -.55, -.5, vec3(.0,.0,.0));
    //slash_raster(grayColor, uv, -.55, -.5, uvPix);

    // KICK
    blit(grayColor, uv, vec2(-.2,-.715), vec2(2.,1.55), uvPix);

    band(o.rgb, uv, .3, grayColor);

    band(o.rgb, uv, -.69, vec3(0,0,0));
    
    //band(o.rgb, uv, -.73, vec3(1,.5,0));
    band(o.rgb, uv, -.73, rasterColor.rgb);
    //raster_band(o.rgb, uv, -.73, uvPix);
    
    band(o.rgb, uv, -.8, vec3(1,1,1));


    // POST PROCESSING
		vec2 uvn = gl_FragCoord.xy / iResolution.xy - .5;
		uvn *= 2.;

    o.rgb *=1.-(rand(uvPix+fract(iGlobalTime))*.25);// noise
    o.rgb = pow(o.rgb, vec3(1./1.9));// gamma
    o.rgb *= 1.-dot(uvn*.7, uvn*.7);// vignette
    //o.rgb = pow(o.rgb, vec3(1./2.2));// gamma

    // fade-in
    o.rgb *= smoothstep(0., 1.3, iGlobalTime - .1);

    gl_FragColor = vec4(o.rgb, 1.);

   //  if(length(uv-vec2(-.7,-.7)) < 0.03)
			// gl_FragColor = vec4(1,0,0,1);
   //  if(length(uv-vec2(.9,.9)) < 0.03)
			// gl_FragColor = vec4(1,0,0,1);
		//if(uv.y < 0.)
		//	gl_FragColor *= .5;
		//if(uv.x < 0.)
		//	gl_FragColor *= .5;
	}
	</script>


</head>
<body>
	<div id="glBody"></div>
	<div id="notglBody">
		<div id="desc">
			<p>An audio-visual
			Underground electric acid jazz, brought to life with .
			Audio/visual gateway to demoscene acid jazz.
			A worldwide collaboration of underground artists, musicians, programmers, delivering
			a performance of live music and realtime visuals.
			</p>
			<br />
			<p>
				<a href="https://www.facebook.com/slashKICK/">[facebook]</a>
				<a href="https://soundcloud.com/slash-kick">[soundcloud]</a>
			</p>
			<br />
			<p><a href="mailto:info@slashkick.be">info@slashkick.be</a></p>
		</div>
	</div>
</body>
</html>


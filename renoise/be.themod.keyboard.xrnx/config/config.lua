-- themod keyboard
-- 2015-10-22
require('../utility')
require('config/ModSong')

-- todo: ctrl+f "todo"


--------------------------------------------------------------------------------------------
class 'ModConfig'

function ModConfig:__init(raw)
	self.raw = raw

	-- also process aliases
	local temp = {}
	if raw.Aliases then
		self.aliases = raw.Aliases
		for k, v in pairs(raw.Aliases) do
			temp[k] = self:substituteAliases(v)
		end
		self.aliases = temp
	end

	self.settings = {}
	if raw.Settings then
		for k, v in pairs(raw.Settings) do
			self.settings[k] = self:substituteAliases(v)
		end
	end

	self.hotkeyAssignments = {}
	if raw.HotkeyAssignments then
		for k, v in pairs(raw.HotkeyAssignments) do
			self.hotkeyAssignments[k] = ModHotkeyAssignment(self, v)-- self:substituteAliases(v)
		end
	end

	self.colorSchemes = { }
	if raw.ColorSchemes then
		for k, v in pairs(raw.ColorSchemes) do
			self.colorSchemes[k] = ModColorScheme(self, v)
		end
	end

	self.deviceDefs = {}
	if raw.DeviceDefs then
		for k, v in pairs(raw.DeviceDefs) do
			table.insert(self.deviceDefs, ModDeviceDef(self, v))
		end
	end

	self.patches = {}
	if raw.Patches then
		for k, v in pairs(raw.Patches) do
			self.patches[k] = ModPatch(self, v)
		end
	end

	self.samples = {}
	if raw.Samples then
		for k, v in pairs(raw.Samples) do
			self.samples[k] = ModSample(self, v)
		end
	end

	self.songs = {}-- ARRAY
	if raw.Songs then
		for k, v in pairs(raw.Songs) do
			table.insert(self.songs, ModSong(self, v))
		end
	end

	-- fix up inheritance of color schemes

	-- fix up inheritance of songs

	-- fix up inheritance of samples

end


-- converts @Key to the value associated with the alias "Key". If anything goes wrong, returns "#Key"
function ModConfig:substituteAliases(s)
	if s == nil then return nil end
	if #s < 3 then return s end
	if not StringStartsWith2(s, "@") then return s end
	local k = string.sub(s, 2)
	local v = self.aliases[k]
	if not v then return s end
	return v
end


function ModConfig:parseObjectName(raw, unnamedObjName)
	if raw then
		return self:substituteAliases(raw)
	else
		return "__unnamed_"..unnamedObjName.."_"..tostring(getUniqueObjectID())
	end
end


function ModConfig:findSong(name)
	for _,v in pairs(self.songs) do
		if string.lower(v.name) == string.lower(name) then
			return v
		end
	end
	return nil
end


function ModConfig:findButtonDef(buttonName)
	for _, dd in pairs(self.deviceDefs) do
		for _, b in pairs(dd.buttonDefs) do
			if b.name == buttonName then return b end
		end
	end
	return nil
end


function ModConfig:findHotkeyAssignment(hkName)
	--log("you are searchingf or  a hotkey: ".. hkName)
	for _,hk in pairs(self.hotkeyAssignments) do
		--log("hk.name = "..hk.name..", hkName = "..hkName)
		if string.lower(hk.name) == string.lower(hkName) then
			return hk
		end
	end
	return nil
end

-- guaranteed to return a valid object unless allowNil is true
function ModConfig:findColorScheme(csName, allowNil)
	for _,cs in pairs(self.colorSchemes) do
		if string.lower(cs.name) == string.lower(csName) then
			return cs
		end
	end
	if allowNil then return nil end
	-- return default color scheme.
	return ModColorScheme(self, {
		Normal = "#003",
		Active = "#606",
		Pressed = "#880"
	})
end

function ModConfig:getBaseColorSchemeName()
	return self:findSetting("BaseColorScheme", "__base")
end

-- raw is either a color scheme name, or a color scheme object to be parsed, inserted, and we return the autogenerated name.
-- OR if it's nil, then it's the base color scheme.
function ModConfig:getColorSchemeName(raw)
	if type(raw) == "string" then
		return self:substituteAliases(raw)
	end
	if raw == nil then
		return self:getBaseColorSchemeName()
	end
	local cs = ModColorScheme(config, raw)
	table.insert(config.colorSchemes, cs)
	return cs.name
end


function ModConfig:findPatch(patchName)
	for _,p in pairs(self.patches) do
		if string.lower(p.name) == string.lower(patchName) then
			return p
		end
	end
	return nil
end

function ModConfig:findSetting(settingName, default)
	for k,v in pairs(self.settings) do
		if string.lower(k) == string.lower(settingName) then
			return v
		end
	end
	return default
end

function ModConfig:findSample(sampleName)
	for k,v in pairs(self.samples) do
		if string.lower(k) == string.lower(sampleName) then
			return v
		end
	end
	return nil
end


--------------------------------------------------------------------------------------------
class 'ModColorScheme'

function ModColorScheme:__init(config, raw)
	self.raw = raw
	self.config = config

	if raw.Name then
		self.name = config:substituteAliases(raw.Name)
	else
		self.name = "__unnamed_ColorScheme_"..tostring(getUniqueObjectID())
	end

	self.inherits = config:substituteAliases(raw.Inherits)
	if not self.inherits then self.inherits = config:getBaseColorSchemeName() end

	self.normal = string_to_rgb(config:substituteAliases(raw.Normal))
	self.active = string_to_rgb(config:substituteAliases(raw.Active))
	self.pressed = string_to_rgb(config:substituteAliases(raw.Pressed))

	local parent = config:findColorScheme(self.inherits, true)
	if parent then
		if not self.normal then self.normal = parent.normal end
		if not self.active then self.active = parent.active end
		if not self.pressed then self.pressed = parent.pressed end
	end
end

--------------------------------------------------------------------------------------------
class 'ModHotkeyAssignment'

function ModHotkeyAssignment:__init(config, raw)
	self.config = config
	self.raw = raw

	if raw.Name then
		self.name = config:substituteAliases(raw.Name)
	else
		self.name = "__unnamed_Hotkey_"..tostring(getUniqueObjectID())
	end

	assert(self.name, "hotkey name is nil wat?")
	assert(raw.ButtonName, "hotkey ButtonName is nil wat?")

	self.buttonName = config:substituteAliases(raw.ButtonName)
	self.colorScheme = config:getColorSchemeName(raw.ColorScheme)
end

--------------------------------------------------------------------------------------------
class 'ModDeviceDef'

function ModDeviceDef:__init(config, raw)
	self.config = config
	self.raw = raw

	if raw.Name then
		self.name = config:substituteAliases(raw.Name)
	else
		self.name = "__unnamed_DeviceDef_"..tostring(getUniqueObjectID())
	end

	self.outputDeviceName = raw.OutputDeviceName
	self.inputDeviceName = raw.InputDeviceName
	self.isLaunchpadPro = toBoolean(raw.IsLaunchpadPro)

	self.buttonDefs = {}

	if self.isLaunchpadPro then
		for x = 0, 9 do
			for y = 0, 9 do
				local btn = LaunchpadProButton(x, y)
				self.buttonDefs[btn.name] = ModButtonDef(config, self, { Name = btn.name, LPPKey = btn.name })
			end
		end
	end

	if raw.ButtonDefs then
		for k, v in pairs(raw.ButtonDefs) do
			self.buttonDefs[k] = ModButtonDef(config, self, v)
		end
	end
end


class 'ModButtonDef'

function ModButtonDef:__init(config, deviceDef, raw)
	self.config = config
	self.raw = raw
	self.deviceDef = deviceDef

	if raw.Name then
		self.name = config:substituteAliases(raw.Name)
	else
		self.name = "__unnamed_Button_"..tostring(getUniqueObjectID())
	end

	if raw.LPPKey then
		local proc = config:substituteAliases(raw.LPPKey)
		self.LPPKey = LaunchpadProButton(proc)
		--log("LPPKEY: " .. self.LPPKey)
	end

	if raw.CC then
		self.MidiCC = tonumber(config:substituteAliases(raw.CC))
	end

	if raw.Note then
		self.MidiNote = KeyRangeStringToValue(config:substituteAliases(raw.Note))
	end
	if raw.Channel then
		self.MidiChannel = tonumber(config:substituteAliases(raw.Channel))
	end
end


--------------------------------------------------------------------------------------------
class 'ModSample'

function ModSample:__init(config, raw)
	self.config = config
	self.raw = raw

	if raw.Name then
		self.name = config:substituteAliases(raw.Name)
	else
		self.name = "__unnamed_Sample_"..tostring(getUniqueObjectID())
	end
	--log("added sample "..self.name)

	self.layers = {}
	if raw.Layers then
		for k, v in pairs(raw.Layers) do
			local layer = ModSampleLayer(config, self, v)
			self.layers[k] = layer
			--log("added sample verbose layer")
		end
	end

	-- you can also define a sample with only 1 layer by defining it AS a layer.
	local selfLayer = ModSampleLayer(config, self, raw)
	if selfLayer.instrumentName and selfLayer.note then
		table.insert(self.layers, selfLayer)
		--log("added sample self layer")
	end
end


class 'ModSampleLayer'

function ModSampleLayer:__init(config, sample, raw)
	self.config = config
	self.sample = sample
	self.raw = raw

	self.instrumentName = config:substituteAliases(raw.Instrument)
	self.note = KeyRangeStringToValue(config:substituteAliases(raw.Note))
	self.velocity = tonumber(config:substituteAliases(raw.Velocity))
	-- track?
end


--------------------------------------------------------------------------------------------
class 'ModPatch'

function ModPatch:__init(config, raw)
	self.config = config
	self.raw = raw

	if raw.Name then
		self.name = config:substituteAliases(raw.Name)
	else
		self.name = "__unnamed_Patch_"..tostring(getUniqueObjectID())
	end

	self.layers = {}
	if raw.Layers then
		for k, v in pairs(raw.Layers) do
			self.layers[k] = ModPatchLayer(config, self, v)
		end
	end

end

class 'ModPatchLayer'

function ModPatchLayer:__init(config, patch, raw)
	self.config = config
	self.raw = raw
	self.patch = patch

	self.instrumentName = config:substituteAliases(raw.Instrument)
	self.channel = tonumber(config:substituteAliases(raw.Channel)) or 0
	self.transpose = tonumber(config:substituteAliases(raw.Transpose)) or 0
	self.gain = tonumber(config:substituteAliases(raw.Gain)) or 0.0
	self.keyRange = ParseKeyRange(config:substituteAliases(raw.KeyRange)) or { 0, 119 }

	-- validation
	if self.gain > 6. then
		error("gain cannot be greater than 6db")
	end

end


-- themod keyboard
-- 2015-10-22
require('utility')

-- todo: ctrl+f "todo"


--------------------------------------------------------------------------------------------
class 'ModConfig'

-- converts @Key to the value associated with the alias "Key". If anything goes wrong, returns "#Key"
function ModConfig:substituteAliases(s)
	if s == nil then return nil end
	if #s < 3 then return s end
	if not StringStartsWith2(s, "@") then return s end
	local k = string.sub(s, 2)
	local v = self.aliases[k]
	if not v then return s end
	return v
end

function ModConfig:__init(raw)

	self.raw = raw

	-- also process aliases
	local temp = {}
	if raw.Aliases then
		self.aliases = raw.Aliases
		for k, v in pairs(raw.Aliases) do
			temp[k] = self:substituteAliases(v)
		end
		self.aliases = temp
	end

	self.settings = {}
	if raw.Settings then
		for k, v in pairs(raw.Settings) do
			self.settings[k] = self:substituteAliases(v)
		end
	end

	self.hotkeyAssignments = {}
	if raw.HotkeyAssignments then
		for k, v in pairs(raw.HotkeyAssignments) do
			self.hotkeyAssignments[k] = ModHotkeyAssignment(self, v)-- self:substituteAliases(v)
		end
	end

	self.colorSchemes = { }
	if raw.ColorSchemes then
		for k, v in pairs(raw.ColorSchemes) do
			self.colorSchemes[k] = ModColorScheme(self, v)
		end
	end

	self.deviceDefs = {}
	if raw.DeviceDefs then
		for k, v in pairs(raw.DeviceDefs) do
			table.insert(self.deviceDefs, ModDeviceDef(self, v))
		end
	end

	self.patches = {}
	if raw.Patches then
		for k, v in pairs(raw.Patches) do
			self.patches[k] = ModPatch(self, v)
		end
	end

	self.samples = {}
	if raw.Samples then
		for k, v in pairs(raw.Samples) do
			self.samples[k] = ModSample(self, v)
		end
	end

	self.songs = {}-- ARRAY
	if raw.Songs then
		for k, v in pairs(raw.Songs) do
			table.insert(self.songs, ModSong(self, v))
		end
	end

	-- fix up inheritance of color schemes

	-- fix up inheritance of songs

	-- fix up inheritance of samples

end


function ModConfig:findButtonDef(buttonName)
	--log("FindButtonDef("..buttonName..")..")
	for _, dd in pairs(self.deviceDefs) do
		for _, b in pairs(dd.buttonDefs) do
			--log("...comparing "..buttonName.." to " .. b.name)
			if b.name == buttonName then return b end
		end
	end
	return nil
end


function ModConfig:findHotkeyAssignment(hkName)
	--log("you are searchingf or  a hotkey: ".. hkName)
	for _,hk in pairs(self.hotkeyAssignments) do
		--log("hk.name = "..hk.name..", hkName = "..hkName)
		if string.lower(hk.name) == string.lower(hkName) then
			return hk
		end
	end
	return nil
end

function ModConfig:findColorScheme(csName)
	for _,cs in pairs(self.colorSchemes) do
		if string.lower(cs.name) == string.lower(csName) then
			return cs
		end
	end
	return nil
end

function ModConfig:findPatch(patchName)
	for _,p in pairs(self.patches) do
		if string.lower(p.name) == string.lower(patchName) then
			return p
		end
	end
	return nil
end

function ModConfig:findSetting(settingName, default)
	for k,v in pairs(self.settings) do
		if string.lower(k) == string.lower(settingName) then
			return v
		end
	end
	return default
end

function ModConfig:findSample(sampleName)
	for k,v in pairs(self.samples) do
		if string.lower(k) == string.lower(sampleName) then
			return v
		end
	end
	return nil
end


-- raw is either a color scheme name, or a color scheme object to be parsed, inserted, and we return the autogenerated name.
function ModConfig:getColorSchemeName(raw)
	if type(raw) == "string" then
		return config:substituteAliases(raw)
	else
	local cs = ModColorScheme(config, raw)
	table.insert(config.colorSchemes, cs)
	return cs.name
end

--------------------------------------------------------------------------------------------
class 'ModColorScheme'

function ModColorScheme:__init(config, raw)
	self.config = config
	if raw.Name then
		self.name = config:substituteAliases(raw.Name)
	else
		self.name = "__unnamed_ColorScheme_"..tostring(getUniqueObjectID())
	end

	self.raw = raw

	self.normal = string_to_rgb(config:substituteAliases(raw.Normal))
	self.active = string_to_rgb(config:substituteAliases(raw.Active))
end

--------------------------------------------------------------------------------------------
class 'ModHotkeyAssignment'

function ModHotkeyAssignment:__init(config, raw)
	self.config = config
	self.raw = raw

	if raw.Name then
		self.name = config:substituteAliases(raw.Name)
	else
		self.name = "__unnamed_Hotkey_"..tostring(getUniqueObjectID())
	end

	assert(self.name, "hotkey name is nil wat?")
	assert(raw.ButtonName, "hotkey ButtonName is nil wat?")

	self.buttonName = config:substituteAliases(raw.ButtonName)
	self.colorScheme = config:getColorSchemeName(raw.ColorScheme)
end

--------------------------------------------------------------------------------------------
class 'ModDeviceDef'

function ModDeviceDef:__init(config, raw)
	self.config = config
	self.raw = raw

	if raw.Name then
		self.name = config:substituteAliases(raw.Name)
	else
		self.name = "__unnamed_DeviceDef_"..tostring(getUniqueObjectID())
	end

	self.outputDeviceName = raw.OutputDeviceName
	self.inputDeviceName = raw.InputDeviceName
	self.isLaunchpadPro = toBoolean(raw.IsLaunchpadPro)

	self.buttonDefs = {}

	if self.isLaunchpadPro then
		for x = 0, 9 do
			for y = 0, 9 do
				local btn = LaunchpadProButton(x, y)
				self.buttonDefs[btn.name] = ModButtonDef(config, self, { Name = btn.name, LPPKey = btn.name })
			end
		end
	end

	if raw.ButtonDefs then
		for k, v in pairs(raw.ButtonDefs) do
			self.buttonDefs[k] = ModButtonDef(config, self, v)
		end
	end
end


class 'ModButtonDef'

function ModButtonDef:__init(config, deviceDef, raw)
	self.config = config
	self.raw = raw
	self.deviceDef = deviceDef

	if raw.Name then
		self.name = config:substituteAliases(raw.Name)
	else
		self.name = "__unnamed_Button_"..tostring(getUniqueObjectID())
	end

	if raw.LPPKey then
		local proc = config:substituteAliases(raw.LPPKey)
		self.LPPKey = LaunchpadProButton(proc)
		--log("LPPKEY: " .. self.LPPKey)
	end

	if raw.CC then
		self.MidiCC = tonumber(config:substituteAliases(raw.CC))
	end

	if raw.Note then
		self.MidiNote = KeyRangeStringToValue(config:substituteAliases(raw.Note))
	end
	if raw.Channel then
		self.MidiChannel = tonumber(config:substituteAliases(raw.Channel))
	end
end


--------------------------------------------------------------------------------------------
class 'ModSample'

function ModSample:__init(config, raw)
	self.config = config
	self.raw = raw

	if raw.Name then
		self.name = config:substituteAliases(raw.Name)
	else
		self.name = "__unnamed_Sample_"..tostring(getUniqueObjectID())
	end
	--log("added sample "..self.name)

	self.layers = {}
	if raw.Layers then
		for k, v in pairs(raw.Layers) do
			local layer = ModSampleLayer(config, self, v)
			self.layers[k] = layer
			--log("added sample verbose layer")
		end
	end

	-- you can also define a sample with only 1 layer by defining it AS a layer.
	local selfLayer = ModSampleLayer(config, self, raw)
	if selfLayer.instrumentName and selfLayer.note then
		table.insert(self.layers, selfLayer)
		--log("added sample self layer")
	end
end


class 'ModSampleLayer'

function ModSampleLayer:__init(config, sample, raw)
	self.config = config
	self.sample = sample
	self.raw = raw

	self.instrumentName = config:substituteAliases(raw.Instrument)
	self.note = KeyRangeStringToValue(config:substituteAliases(raw.Note))
	self.velocity = tonumber(config:substituteAliases(raw.Velocity))
	-- track?
end


--------------------------------------------------------------------------------------------
class 'ModPatch'

function ModPatch:__init(config, raw)
	self.config = config
	self.raw = raw

	if raw.Name then
		self.name = config:substituteAliases(raw.Name)
	else
		self.name = "__unnamed_Patch_"..tostring(getUniqueObjectID())
	end

	self.layers = {}
	if raw.Layers then
		for k, v in pairs(raw.Layers) do
			self.layers[k] = ModPatchLayer(config, self, v)
		end
	end

end

class 'ModPatchLayer'

function ModPatchLayer:__init(config, patch, raw)
	self.config = config
	self.raw = raw
	self.patch = patch

	self.instrumentName = config:substituteAliases(raw.Instrument)
	self.channel = tonumber(config:substituteAliases(raw.Channel)) or 0
	self.transpose = tonumber(config:substituteAliases(raw.Transpose)) or 0
	self.gain = tonumber(config:substituteAliases(raw.Gain)) or 0.0
	self.keyRange = ParseKeyRange(config:substituteAliases(raw.KeyRange)) or { 0, 119 }

	-- validation
	if self.gain > 6. then
		error("gain cannot be greater than 6db")
	end

end


--------------------------------------------------------------------------------------------
class 'ModSong'

function ModSong:__init(config, raw)
	self.config = config
	self.raw = raw
	if raw.Name then
		self.name = config:substituteAliases(raw.Name)
	else
		self.name = "__unnamed_Song_"..tostring(getUniqueObjectID())
	end

	self.inherits = config:substituteAliases(raw.Inherits)
	self.image = config:substituteAliases(raw.Image)

	self.buttonMap = {}-- array
	if raw.ButtonMap then
		for k, v in pairs(raw.ButtonMap) do
			self.buttonMap[k] = ModSongButtonMapping(config, self, v)
		end
	end

end

class 'ModSongButtonMapping'

function ModSongButtonMapping:__init(config, song, raw)
	self.config = config
	self.raw = raw
	self.song = song

	self.buttonName = config:substituteAliases(raw.Button)
	self.colorScheme = config:getColorSchemeName(raw.ColorScheme)

	self.patchAssignments = {}
	if raw.PatchAssignments then
		for k, v in pairs(raw.PatchAssignments) do
			self.patchAssignments[k] = ModSongButtonPatchAssignment(config, self, song, v)
		end
	end

	self.sampleTriggers = {}-- always sample names
	--log("parsing sample triggers..." .. tostring(raw.SampleTriggers))
	if raw.SampleTriggers then
		for k, v in pairs(raw.SampleTriggers) do
			local sampleName = nil
			if type(v) == "string" then
				sampleName = config:substituteAliases(v)
				--log("song sample trigger parsed: "..sampleName)
			else
				local sample = ModSample(self.config, v)
				table.insert(self.config.samples, sample)
				sampleName = sample.name
				--log("created unnamed sample "..sampleName)
			end

			self.sampleTriggers[k] = sampleName
		end
	end

	-- setVariable

end

class 'ModSongButtonPatchAssignment'

function ModSongButtonPatchAssignment:__init(config, mapping, song, raw)
	self.config = config
	self.raw = raw
	self.mapping = mapping
	self.song = song

	self.outputDeviceName = config:substituteAliases(raw.OutputDevice)

	if type(raw.Patch) == "string" then
		self.patchName = config:substituteAliases(raw.Patch)
	else
		local patch = ModPatch(config, raw.Patch)
		table.insert(config.patches, patch)
		self.patchName = patch.name
	end
end


